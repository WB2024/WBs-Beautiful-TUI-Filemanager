#!/usr/bin/env python3
"""
Interactive CLI File Manager with Arrow Key Navigation and Bookmarks
Navigate directories, manage permissions, extract archives, and find empty folders
"""

import os
import sys
import stat
import subprocess
import shutil
import curses
import json
from pathlib import Path
from collections import defaultdict
import mimetypes

# Configuration file for bookmarks
CONFIG_FILE = Path.home() / '.filemanager_config.json'


class Config:
    """Handle configuration and bookmarks"""
    
    def __init__(self):
        self.bookmarks = {}
        self.load()
    
    def load(self):
        """Load configuration from file"""
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    self.bookmarks = data.get('bookmarks', {})
            except:
                self.bookmarks = {}
    
    def save(self):
        """Save configuration to file"""
        try:
            with open(CONFIG_FILE, 'w') as f:
                json.dump({'bookmarks': self.bookmarks}, f, indent=2)
        except:
            pass
    
    def add_bookmark(self, name, path):
        """Add a bookmark"""
        self.bookmarks[name] = str(path)
        self.save()
    
    def remove_bookmark(self, name):
        """Remove a bookmark"""
        if name in self.bookmarks:
            del self.bookmarks[name]
            self.save()
    
    def get_bookmarks(self):
        """Get all bookmarks"""
        return self.bookmarks


class FileManager:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.current_dir = Path.cwd()
        self.selected_index = 0
        self.scroll_offset = 0
        self.running = True
        self.entries = []
        self.config = Config()
        self.show_help = False
        self.message = ""
        self.message_color = curses.COLOR_GREEN
        
        # Initialize colors
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_CYAN, -1)      # Directories
        curses.init_pair(2, curses.COLOR_GREEN, -1)     # Executables/Archives
        curses.init_pair(3, curses.COLOR_YELLOW, -1)    # Media files
        curses.init_pair(4, curses.COLOR_MAGENTA, -1)   # Audio files
        curses.init_pair(5, curses.COLOR_RED, -1)       # Video files
        curses.init_pair(6, curses.COLOR_WHITE, -1)     # Regular files
        curses.init_pair(7, curses.COLOR_BLACK, curses.COLOR_CYAN)  # Selection
        curses.init_pair(8, curses.COLOR_GREEN, -1)     # Success messages
        curses.init_pair(9, curses.COLOR_RED, -1)       # Error messages
        curses.init_pair(10, curses.COLOR_YELLOW, -1)   # Warning messages
        curses.init_pair(11, curses.COLOR_BLUE, -1)     # Info
        
        # Hide cursor
        curses.curs_set(0)
        
        # Load directory
        self.load_directory()
    
    def get_size_string(self, size_bytes):
        """Convert bytes to human-readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:6.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:6.1f} PB"
    
    def get_permissions_string(self, path):
        """Get permissions string for a file/directory"""
        try:
            st = path.stat()
            mode = st.st_mode
            return stat.filemode(mode)
        except:
            return "???????????"
    
    def get_file_type_category(self, path):
        """Categorize file by type"""
        if path.is_dir():
            return "directory"
        
        ext = path.suffix.lower()
        
        # Audio
        if ext in {'.mp3', '.flac', '.wav', '.m4a', '.aac', '.ogg', '.opus', '.wma', '.ape', '.alac'}:
            return "audio"
        
        # Video
        if ext in {'.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.mpg', '.mpeg'}:
            return "video"
        
        # Images
        if ext in {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.tiff', '.ico'}:
            return "image"
        
        # Text/Documents
        if ext in {'.txt', '.log', '.md', '.doc', '.docx', '.pdf', '.rtf', '.odt'}:
            return "document"
        
        # Archives
        if ext in {'.zip', '.tar', '.gz', '.tgz', '.bz2', '.tbz2', '.xz', '.txz', '.rar', '.7z'}:
            return "archive"
        
        # Code
        if ext in {'.py', '.js', '.java', '.c', '.cpp', '.h', '.cs', '.php', '.rb', '.go', '.rs'}:
            return "code"
        
        # Data
        if ext in {'.json', '.xml', '.yaml', '.yml', '.csv', '.sql', '.db', '.sqlite'}:
            return "data"
        
        return "other"
    
    def get_file_color(self, entry):
        """Get color pair for file type"""
        if entry['is_dir']:
            return curses.color_pair(1)  # Cyan for directories
        
        path = entry['path']
        ext = path.suffix.lower()
        
        # Archives
        if ext in {'.zip', '.tar', '.gz', '.tgz', '.bz2', '.tbz2', '.xz', '.txz', '.rar', '.7z'}:
            return curses.color_pair(2)  # Green
        
        # Audio
        if ext in {'.mp3', '.flac', '.wav', '.m4a', '.aac', '.ogg', '.opus', '.wma'}:
            return curses.color_pair(4)  # Magenta
        
        # Video
        if ext in {'.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm'}:
            return curses.color_pair(5)  # Red
        
        # Images
        if ext in {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp'}:
            return curses.color_pair(3)  # Yellow
        
        return curses.color_pair(6)  # White for regular files
    
    def get_file_icon(self, entry):
        """Get icon for file type"""
        if entry['is_dir']:
            return "üìÅ"
        
        path = entry['path']
        ext = path.suffix.lower()
        
        if ext in {'.zip', '.tar', '.gz', '.tgz', '.bz2', '.tbz2', '.xz', '.txz', '.rar', '.7z'}:
            return "üì¶"
        if ext in {'.mp3', '.flac', '.wav', '.m4a', '.aac', '.ogg', '.opus', '.wma'}:
            return "üéµ"
        if ext in {'.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm'}:
            return "üé¨"
        if ext in {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp'}:
            return "üñºÔ∏è"
        if ext in {'.txt', '.log', '.md'}:
            return "üìù"
        
        return "üìÑ"
    
    def analyze_directory_contents(self, path):
        """Analyze directory contents - count files by type and get total size"""
        file_types = defaultdict(int)
        file_type_sizes = defaultdict(int)
        total_files = 0
        total_size = 0
        
        try:
            for item in path.rglob('*'):
                if item.is_file():
                    total_files += 1
                    try:
                        size = item.stat().st_size
                        total_size += size
                        
                        file_type = self.get_file_type_category(item)
                        file_types[file_type] += 1
                        file_type_sizes[file_type] += size
                    except:
                        pass
        except:
            pass
        
        return {
            'total_files': total_files,
            'total_size': total_size,
            'file_types': dict(file_types),
            'file_type_sizes': dict(file_type_sizes)
        }
    
    def get_directory_file_list(self, path, max_depth=3):
        """Get a hierarchical list of files in directory"""
        files_by_type = defaultdict(list)
        
        try:
            for item in path.rglob('*'):
                if item.is_file():
                    # Calculate relative path
                    try:
                        rel_path = item.relative_to(path)
                        depth = len(rel_path.parts) - 1
                        
                        if depth <= max_depth:
                            file_type = self.get_file_type_category(item)
                            size = item.stat().st_size
                            
                            files_by_type[file_type].append({
                                'name': item.name,
                                'path': str(rel_path),
                                'size': size
                            })
                    except:
                        pass
        except:
            pass
        
        return dict(files_by_type)
    
    def load_directory(self):
        """Load current directory contents"""
        self.entries = []
        
        # Add parent directory entry if not at root
        if self.current_dir != self.current_dir.parent:
            self.entries.append({
                'name': '..',
                'path': self.current_dir.parent,
                'is_dir': True,
                'size': 0,
                'perms': ''
            })
        
        try:
            items = list(self.current_dir.iterdir())
            
            # Separate and sort directories and files
            dirs = sorted([e for e in items if e.is_dir()], key=lambda x: x.name.lower())
            files = sorted([e for e in items if e.is_file()], key=lambda x: x.name.lower())
            
            # Add directories
            for d in dirs:
                self.entries.append({
                    'name': d.name,
                    'path': d,
                    'is_dir': True,
                    'size': 0,
                    'perms': self.get_permissions_string(d)
                })
            
            # Add files
            for f in files:
                try:
                    size = f.stat().st_size
                except:
                    size = 0
                
                self.entries.append({
                    'name': f.name,
                    'path': f,
                    'is_dir': False,
                    'size': size,
                    'perms': self.get_permissions_string(f)
                })
        
        except PermissionError:
            self.message = "Permission denied reading directory"
            self.message_color = curses.COLOR_RED
        
        # Reset selection if out of bounds
        if self.selected_index >= len(self.entries):
            self.selected_index = max(0, len(self.entries) - 1)
    
    def draw_header(self):
        """Draw header with current path"""
        height, width = self.stdscr.getmaxyx()
        
        # Title bar
        title = " üóÇÔ∏è  INTERACTIVE FILE MANAGER üóÇÔ∏è "
        self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
        self.stdscr.addstr(0, 0, title.center(width)[:width])
        self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
        
        # Current path
        path_str = f"üìÅ {self.current_dir}"
        if len(path_str) > width - 2:
            path_str = "üìÅ ..." + path_str[-(width-6):]
        self.stdscr.addstr(1, 1, path_str[:width-2], curses.color_pair(11) | curses.A_BOLD)
        
        # Separator
        self.stdscr.addstr(2, 0, "‚îÄ" * width)
    
    def draw_footer(self):
        """Draw footer with help"""
        height, width = self.stdscr.getmaxyx()
        
        # Separator
        self.stdscr.addstr(height - 4, 0, "‚îÄ" * width)
        
        # Help text
        if self.show_help:
            help_lines = [
                "‚Üë/‚Üì: Navigate  Enter: Open  Backspace: Go Up  h: Home  r: Root",
                "p: Permissions  e: Extract  f: Find Empty  b: Bookmarks  q: Quit",
                "Press ? to hide help"
            ]
        else:
            help_lines = [
                "Press ? for help"
            ]
        
        for i, line in enumerate(help_lines):
            if height - 3 + i < height:
                self.stdscr.addstr(height - 3 + i, 1, line[:width-2], curses.color_pair(11))
        
        # Message
        if self.message:
            color = curses.color_pair(8) if self.message_color == curses.COLOR_GREEN else curses.color_pair(9)
            msg = self.message[:width-2]
            self.stdscr.addstr(height - 1, 1, msg, color | curses.A_BOLD)
    
    def draw_entries(self):
        """Draw file/directory entries"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate visible area
        visible_start = 3
        visible_end = height - 4
        visible_count = visible_end - visible_start
        
        # Adjust scroll offset
        if self.selected_index < self.scroll_offset:
            self.scroll_offset = self.selected_index
        elif self.selected_index >= self.scroll_offset + visible_count:
            self.scroll_offset = self.selected_index - visible_count + 1
        
        # Draw entries
        for i in range(visible_count):
            entry_index = i + self.scroll_offset
            
            if entry_index >= len(self.entries):
                break
            
            entry = self.entries[entry_index]
            y_pos = visible_start + i
            
            # Determine if selected
            is_selected = entry_index == self.selected_index
            
            # Build display string
            icon = self.get_file_icon(entry)
            name = entry['name']
            
            # Size string
            if entry['is_dir']:
                size_str = "    <DIR>"
            else:
                size_str = self.get_size_string(entry['size'])
            
            # Permissions
            perms = entry['perms']
            
            # Calculate available width for name
            prefix = f"{icon} "
            suffix = f" {perms} {size_str}"
            available_width = width - len(prefix) - len(suffix) - 4
            
            if len(name) > available_width:
                name = name[:available_width-3] + "..."
            
            display = f"{prefix}{name:<{available_width}}{suffix}"
            
            # Draw with appropriate color
            if is_selected:
                self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
                self.stdscr.addstr(y_pos, 1, display[:width-2])
                self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            else:
                color = self.get_file_color(entry)
                self.stdscr.addstr(y_pos, 1, display[:width-2], color)
        
        # Draw scrollbar if needed
        if len(self.entries) > visible_count:
            scrollbar_height = visible_count
            scrollbar_pos = int((self.scroll_offset / len(self.entries)) * scrollbar_height)
            
            for i in range(visible_count):
                y_pos = visible_start + i
                if i == scrollbar_pos:
                    self.stdscr.addstr(y_pos, width - 1, "‚ñà", curses.color_pair(11))
                else:
                    self.stdscr.addstr(y_pos, width - 1, "‚îÇ", curses.color_pair(11))
    
    def draw(self):
        """Draw the entire interface"""
        self.stdscr.clear()
        self.draw_header()
        self.draw_entries()
        self.draw_footer()
        self.stdscr.refresh()
    
    def change_directory(self, new_dir):
        """Change to a new directory"""
        try:
            new_dir = new_dir.resolve()
            if new_dir.exists() and new_dir.is_dir():
                self.current_dir = new_dir
                self.selected_index = 0
                self.scroll_offset = 0
                self.load_directory()
                self.message = ""
            else:
                self.message = "Directory does not exist"
                self.message_color = curses.COLOR_RED
        except Exception as e:
            self.message = f"Error: {e}"
            self.message_color = curses.COLOR_RED
    
    def is_text_file(self, path):
        """Check if a file is likely a text file"""
        # Text file extensions
        text_extensions = {
            '.txt', '.log', '.md', '.markdown', '.rst',
            '.py', '.js', '.jsx', '.ts', '.tsx', '.java', '.c', '.cpp', '.h', '.hpp',
            '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala',
            '.json', '.xml', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf',
            '.html', '.htm', '.css', '.scss', '.sass', '.less',
            '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd',
            '.sql', '.r', '.m', '.lua', '.pl', '.vim', '.el',
            '.tex', '.bib', '.csv', '.tsv', '.dockerfile', '.makefile',
            '.gitignore', '.gitattributes', '.editorconfig', '.env'
        }
        
        path = Path(path)
        ext = path.suffix.lower()
        
        # Check by extension
        if ext in text_extensions:
            return True
        
        # Check for files without extension that are usually text
        if path.name.lower() in {'readme', 'license', 'makefile', 'dockerfile', 'vagrantfile'}:
            return True
        
        return False
    
    def is_audio_file(self, path):
        """Check if a file is an audio file"""
        audio_extensions = {
            '.mp3', '.flac', '.wav', '.m4a', '.aac', '.ogg', '.opus', 
            '.wma', '.ape', '.alac', '.aiff', '.aif', '.dsf', '.dff'
        }
        
        path = Path(path)
        ext = path.suffix.lower()
        return ext in audio_extensions
    
    def is_video_file(self, path):
        """Check if a file is a video file"""
        video_extensions = {
            '.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm',
            '.m4v', '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts',
            '.vob', '.divx', '.xvid', '.f4v', '.rm', '.rmvb'
        }
        
        path = Path(path)
        ext = path.suffix.lower()
        return ext in video_extensions
    
    def handle_enter(self):
        """Handle Enter key - open directory or file"""
        if not self.entries:
            return
        
        entry = self.entries[self.selected_index]
        
        if entry['is_dir']:
            self.change_directory(entry['path'])
        else:
            # Check file type and open appropriate viewer/editor
            if self.is_audio_file(entry['path']):
                # Open audio inspector
                inspector = AudioInspector(self.stdscr, entry['path'], self)
                inspector.run()
                # Reload directory after inspection
                self.load_directory()
            elif self.is_video_file(entry['path']):
                # Open video inspector
                inspector = VideoInspector(self.stdscr, entry['path'], self)
                inspector.run()
                # Reload directory after inspection
                self.load_directory()
            elif self.is_text_file(entry['path']):
                # Open in text editor
                editor = TextEditor(self.stdscr, entry['path'])
                editor.run()
                # Reload directory after editing
                self.load_directory()
            else:
                # For non-text files, show info
                self.message = f"File: {entry['name']} ({self.get_size_string(entry['size'])})"
                self.message_color = curses.COLOR_GREEN
    
    def show_bookmarks_menu(self):
        """Show bookmarks menu"""
        bookmarks = self.config.get_bookmarks()
        
        menu_items = []
        menu_items.append("Add current directory as bookmark")
        
        if bookmarks:
            menu_items.append("‚îÄ" * 40)
            for name, path in bookmarks.items():
                menu_items.append(f"{name}: {path}")
            menu_items.append("‚îÄ" * 40)
            menu_items.append("Remove a bookmark")
        
        menu_items.append("Cancel")
        
        selected = 0
        
        while True:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()
            
            # Title
            title = " BOOKMARKS "
            self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
            self.stdscr.addstr(0, 0, title.center(width)[:width])
            self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            
            self.stdscr.addstr(2, 2, "Use ‚Üë/‚Üì to navigate, Enter to select", curses.color_pair(11))
            self.stdscr.addstr(3, 0, "‚îÄ" * width)
            
            # Menu items
            start_y = 4
            for i, item in enumerate(menu_items):
                if i + start_y >= height - 2:
                    break
                
                if item.startswith("‚îÄ"):
                    self.stdscr.addstr(i + start_y, 2, item[:width-4])
                elif i == selected:
                    self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
                    self.stdscr.addstr(i + start_y, 2, f"‚ñ∫ {item}"[:width-4])
                    self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
                else:
                    self.stdscr.addstr(i + start_y, 2, f"  {item}"[:width-4])
            
            self.stdscr.refresh()
            
            # Handle input
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP:
                selected = max(0, selected - 1)
                # Skip separator lines
                while selected < len(menu_items) and menu_items[selected].startswith("‚îÄ"):
                    selected = max(0, selected - 1)
            elif key == curses.KEY_DOWN:
                selected = min(len(menu_items) - 1, selected + 1)
                # Skip separator lines
                while selected < len(menu_items) and menu_items[selected].startswith("‚îÄ"):
                    selected = min(len(menu_items) - 1, selected + 1)
            elif key in [ord('\n'), curses.KEY_ENTER, 10, 13]:
                selected_item = menu_items[selected]
                
                if selected_item == "Cancel":
                    break
                elif selected_item == "Add current directory as bookmark":
                    name = self.get_text_input("Enter bookmark name: ")
                    if name:
                        self.config.add_bookmark(name, self.current_dir)
                        self.message = f"Bookmark '{name}' added"
                        self.message_color = curses.COLOR_GREEN
                    break
                elif selected_item == "Remove a bookmark":
                    if bookmarks:
                        name = self.get_text_input("Enter bookmark name to remove: ")
                        if name and name in bookmarks:
                            self.config.remove_bookmark(name)
                            self.message = f"Bookmark '{name}' removed"
                            self.message_color = curses.COLOR_GREEN
                        elif name:
                            self.message = f"Bookmark '{name}' not found"
                            self.message_color = curses.COLOR_RED
                    break
                elif ": " in selected_item:
                    # Navigate to bookmark
                    name, path = selected_item.split(": ", 1)
                    self.change_directory(Path(path))
                    break
            elif key == 27:  # ESC
                break
    
    def get_text_input(self, prompt):
        """Get text input from user"""
        height, width = self.stdscr.getmaxyx()
        
        # Show input box
        curses.curs_set(1)
        curses.echo()
        
        self.stdscr.addstr(height - 2, 1, " " * (width - 2))
        self.stdscr.addstr(height - 2, 1, prompt, curses.color_pair(11) | curses.A_BOLD)
        self.stdscr.refresh()
        
        # Get input
        input_str = self.stdscr.getstr(height - 2, 1 + len(prompt), width - len(prompt) - 3).decode('utf-8')
        
        curses.noecho()
        curses.curs_set(0)
        
        return input_str.strip()
    
    def show_message_box(self, title, lines, wait_for_key=True):
        """Show a message box"""
        height, width = self.stdscr.getmaxyx()
        
        box_height = len(lines) + 4
        box_width = min(width - 4, max(len(title) + 4, max(len(line) for line in lines) + 4))
        
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(7))
        for i in range(box_height):
            self.stdscr.addstr(start_y + i, start_x, " " * box_width)
        self.stdscr.attroff(curses.color_pair(7))
        
        # Title
        self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
        self.stdscr.addstr(start_y, start_x + (box_width - len(title)) // 2, title)
        self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
        
        # Lines
        for i, line in enumerate(lines):
            self.stdscr.addstr(start_y + 2 + i, start_x + 2, line[:box_width-4])
        
        if wait_for_key:
            self.stdscr.addstr(start_y + box_height - 1, start_x + 2, "Press any key to continue...", curses.A_BOLD)
        
        self.stdscr.refresh()
        
        if wait_for_key:
            self.stdscr.getch()
    
    def inspect_folder(self, folder_info):
        """Inspect folder contents in detail"""
        path = folder_info['path']
        
        # Show loading message
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, f"Inspecting {folder_info['name']}...", curses.color_pair(11) | curses.A_BOLD)
        self.stdscr.refresh()
        
        # Analyze contents
        analysis = self.analyze_directory_contents(path)
        file_list = self.get_directory_file_list(path)
        
        scroll_offset = 0
        
        while True:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()
            
            # Title
            title = f" INSPECTING: {folder_info['name']} "
            self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
            self.stdscr.addstr(0, 0, title.center(width)[:width])
            self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            
            # Summary
            current_y = 2
            self.stdscr.addstr(current_y, 2, f"üìÅ Path: {path}", curses.color_pair(11) | curses.A_BOLD)
            current_y += 1
            self.stdscr.addstr(current_y, 2, f"üìä Total Size: {self.get_size_string(analysis['total_size'])}", curses.color_pair(8))
            current_y += 1
            self.stdscr.addstr(current_y, 2, f"üìÑ Total Files: {analysis['total_files']}", curses.color_pair(8))
            current_y += 2
            
            # File type breakdown
            self.stdscr.addstr(current_y, 2, "üìã FILE TYPE BREAKDOWN:", curses.color_pair(11) | curses.A_BOLD)
            current_y += 1
            self.stdscr.addstr(current_y, 0, "‚îÄ" * width)
            current_y += 1
            
            # Sort file types by size
            file_types_sorted = sorted(
                analysis['file_types'].items(),
                key=lambda x: analysis['file_type_sizes'].get(x[0], 0),
                reverse=True
            )
            
            # Icons for file types
            type_icons = {
                'audio': 'üéµ',
                'video': 'üé¨',
                'image': 'üñºÔ∏è',
                'document': 'üìù',
                'archive': 'üì¶',
                'code': 'üíª',
                'data': 'üìä',
                'other': 'üìÑ'
            }
            
            # Type colors
            type_colors = {
                'audio': curses.color_pair(4),
                'video': curses.color_pair(5),
                'image': curses.color_pair(3),
                'archive': curses.color_pair(2),
                'code': curses.color_pair(11),
                'document': curses.color_pair(6),
                'data': curses.color_pair(1),
                'other': curses.color_pair(6)
            }
            
            type_section_start = current_y
            
            for file_type, count in file_types_sorted:
                if current_y >= height - 8:
                    break
                
                size = analysis['file_type_sizes'].get(file_type, 0)
                size_str = self.get_size_string(size)
                icon = type_icons.get(file_type, 'üìÑ')
                color = type_colors.get(file_type, curses.color_pair(6))
                
                # Display type summary
                type_display = f"{icon} {file_type.upper()}"
                count_display = f"{count} files"
                
                self.stdscr.addstr(current_y, 4, type_display, color | curses.A_BOLD)
                self.stdscr.addstr(current_y, 25, count_display, color)
                self.stdscr.addstr(current_y, 40, size_str, color)
                current_y += 1
            
            # Separator
            if current_y < height - 6:
                current_y += 1
                self.stdscr.addstr(current_y, 0, "‚îÄ" * width)
                current_y += 1
                
                # Sample files section
                self.stdscr.addstr(current_y, 2, "üìë SAMPLE FILES (grouped by type):", curses.color_pair(11) | curses.A_BOLD)
                current_y += 1
                
                sample_start_y = current_y
                max_samples_per_type = 3
                
                # Show sample files
                for file_type, count in file_types_sorted:
                    if current_y >= height - 3:
                        break
                    
                    if file_type in file_list and file_list[file_type]:
                        icon = type_icons.get(file_type, 'üìÑ')
                        color = type_colors.get(file_type, curses.color_pair(6))
                        
                        # Show up to max_samples_per_type files
                        files = file_list[file_type][:max_samples_per_type]
                        
                        for file_info in files:
                            if current_y >= height - 3:
                                break
                            
                            file_display = f"  {icon} {file_info['path']}"
                            if len(file_display) > width - 20:
                                file_display = file_display[:width-23] + "..."
                            
                            size_str = self.get_size_string(file_info['size'])
                            
                            self.stdscr.addstr(current_y, 4, file_display[:width-20], color)
                            self.stdscr.addstr(current_y, width - 15, size_str, curses.color_pair(6))
                            current_y += 1
                        
                        # Show "and X more..." if there are more files
                        remaining = len(file_list[file_type]) - max_samples_per_type
                        if remaining > 0:
                            self.stdscr.addstr(current_y, 6, f"... and {remaining} more {file_type} files", curses.color_pair(6) | curses.A_DIM)
                            current_y += 1
                        
                        if current_y < height - 3:
                            current_y += 1
            
            # Footer
            self.stdscr.addstr(height - 2, 2, "Press any key to return", curses.color_pair(11))
            
            self.stdscr.refresh()
            
            # Wait for key
            key = self.stdscr.getch()
            break
    
    def fix_permissions(self):
        """Fix permissions on current directory"""
        lines = [
            f"Directory: {self.current_dir}",
            "",
            "This will set permissions to 777 recursively.",
            "Continue? (y/n)"
        ]
        
        self.show_message_box("FIX PERMISSIONS", lines, wait_for_key=False)
        
        key = self.stdscr.getch()
        
        if key in [ord('y'), ord('Y')]:
            try:
                subprocess.run(['chmod', '-R', '777', str(self.current_dir)], check=True)
                self.message = "Permissions updated successfully"
                self.message_color = curses.COLOR_GREEN
            except Exception as e:
                self.message = f"Error: {e}"
                self.message_color = curses.COLOR_RED
        else:
            self.message = "Cancelled"
            self.message_color = curses.COLOR_YELLOW
    
    def extract_archives(self):
        """Extract archives in current directory"""
        # Find archives
        archive_exts = {'.zip', '.tar', '.gz', '.tgz', '.bz2', '.tbz2', '.xz', '.txz', '.rar', '.7z'}
        archives = []
        
        for entry in self.entries:
            if not entry['is_dir']:
                path = entry['path']
                if path.name.lower().endswith(('.tar.gz', '.tar.bz2', '.tar.xz')) or path.suffix.lower() in archive_exts:
                    archives.append(entry)
        
        if not archives:
            self.show_message_box("EXTRACT ARCHIVES", ["No archive files found in current directory"])
            return
        
        # Show selection menu
        selected = 0
        extract_all = False
        
        while True:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()
            
            # Title
            title = " EXTRACT ARCHIVES "
            self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
            self.stdscr.addstr(0, 0, title.center(width)[:width])
            self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            
            self.stdscr.addstr(2, 2, "Use ‚Üë/‚Üì to navigate, Space to toggle, Enter to extract", curses.color_pair(11))
            self.stdscr.addstr(3, 0, "‚îÄ" * width)
            
            # Show archives
            start_y = 4
            self.stdscr.addstr(start_y, 2, "[ ] Extract All", curses.color_pair(11) | curses.A_BOLD)
            if selected == 0:
                self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
                self.stdscr.addstr(start_y, 2, "[X] Extract All" if extract_all else "[ ] Extract All")
                self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            elif extract_all:
                self.stdscr.addstr(start_y, 2, "[X] Extract All", curses.color_pair(2))
            
            for i, archive in enumerate(archives):
                y = start_y + i + 2
                if y >= height - 2:
                    break
                
                name = archive['name']
                size = self.get_size_string(archive['size'])
                display = f"  {name} ({size})"
                
                if i + 1 == selected:
                    self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
                    self.stdscr.addstr(y, 2, f"‚ñ∫ {display}"[:width-4])
                    self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
                else:
                    self.stdscr.addstr(y, 2, f"  {display}"[:width-4])
            
            self.stdscr.addstr(height - 2, 2, "Press 'q' to cancel", curses.color_pair(11))
            
            self.stdscr.refresh()
            
            # Handle input
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP:
                selected = max(0, selected - 1)
            elif key == curses.KEY_DOWN:
                selected = min(len(archives), selected + 1)
            elif key == ord(' '):
                if selected == 0:
                    extract_all = not extract_all
            elif key in [ord('\n'), curses.KEY_ENTER, 10, 13]:
                # Extract
                if extract_all:
                    files_to_extract = archives
                elif selected > 0:
                    files_to_extract = [archives[selected - 1]]
                else:
                    files_to_extract = []
                
                if files_to_extract:
                    self.stdscr.clear()
                    self.stdscr.addstr(0, 0, "Extracting...", curses.color_pair(11) | curses.A_BOLD)
                    self.stdscr.refresh()
                    
                    for archive in files_to_extract:
                        try:
                            subprocess.run(
                                ['extractfile', archive['name']],
                                cwd=str(self.current_dir),
                                capture_output=True
                            )
                        except:
                            pass
                    
                    self.load_directory()
                    self.message = f"Extracted {len(files_to_extract)} archive(s)"
                    self.message_color = curses.COLOR_GREEN
                break
            elif key == ord('q'):
                break
    
    def find_empty_folders(self):
        """Find empty and near-empty folders"""
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "Scanning for empty folders...", curses.color_pair(11) | curses.A_BOLD)
        self.stdscr.refresh()
        
        empty = []
        near_empty = []
        non_empty = []
        
        # Scan directories
        for entry in self.entries:
            if entry['is_dir'] and entry['name'] != '..':
                path = entry['path']
                
                # Analyze directory
                analysis = self.analyze_directory_contents(path)
                total_files = analysis['total_files']
                total_size = analysis['total_size']
                
                folder_info = {
                    'name': entry['name'],
                    'path': path,
                    'size': total_size,
                    'file_count': total_files,
                    'file_types': analysis['file_types'],
                    'file_type_sizes': analysis['file_type_sizes']
                }
                
                if total_files == 0:
                    empty.append(folder_info)
                elif total_size < 10 * 1024 * 1024:  # < 10MB
                    near_empty.append(folder_info)
                else:
                    non_empty.append(folder_info)
        
        # Show results
        all_folders = []
        all_folders.extend(empty)
        all_folders.extend(near_empty)
        all_folders.extend(non_empty)
        
        if not all_folders:
            self.show_message_box("FIND EMPTY FOLDERS", ["No subdirectories found"])
            return
        
        selected = 0
        
        while True:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()
            
            # Title
            title = " EMPTY FOLDER ANALYSIS "
            self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
            self.stdscr.addstr(0, 0, title.center(width)[:width])
            self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
            
            self.stdscr.addstr(2, 2, f"Empty: {len(empty)} | Near-empty: {len(near_empty)} | Non-empty: {len(non_empty)}", curses.color_pair(11))
            self.stdscr.addstr(3, 0, "‚îÄ" * width)
            
            # Show folders
            start_y = 4
            current_y = start_y
            
            for i, folder in enumerate(all_folders):
                if current_y >= height - 3:
                    break
                
                name = folder['name']
                size_str = self.get_size_string(folder['size'])
                
                # Determine category
                if folder in empty:
                    category = "EMPTY"
                    color = curses.color_pair(9)
                    type_str = "(no files)"
                elif folder in near_empty:
                    category = "NEAR-EMPTY"
                    color = curses.color_pair(10)
                    # Build file types string
                    types = []
                    for ftype, count in folder['file_types'].items():
                        types.append(f"{ftype}")
                    type_str = ", ".join(types[:3]) if types else "unknown"
                    if len(types) > 3:
                        type_str += f" +{len(types)-3} more"
                else:
                    category = "NON-EMPTY"
                    color = curses.color_pair(8)
                    # Build file types string
                    types = []
                    for ftype, count in folder['file_types'].items():
                        types.append(f"{ftype}")
                    type_str = ", ".join(types[:3]) if types else "unknown"
                    if len(types) > 3:
                        type_str += f" +{len(types)-3} more"
                
                display = f"{name}/ [{category}] ({size_str}) - {type_str}"
                
                if i == selected:
                    self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
                    self.stdscr.addstr(current_y, 2, f"‚ñ∫ {display}"[:width-4])
                    self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
                else:
                    self.stdscr.addstr(current_y, 2, f"  {display}"[:width-4], color)
                
                current_y += 1
            
            self.stdscr.addstr(height - 2, 2, "‚Üë/‚Üì: Navigate | i: Inspect | d: Delete | q: Cancel", curses.color_pair(11))
            
            self.stdscr.refresh()
            
            # Handle input
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP:
                selected = max(0, selected - 1)
            elif key == curses.KEY_DOWN:
                selected = min(len(all_folders) - 1, selected + 1)
            elif key == ord('i'):
                # Inspect selected folder
                if 0 <= selected < len(all_folders):
                    self.inspect_folder(all_folders[selected])
            elif key == ord('d'):
                # Delete selected
                folder = all_folders[selected]
                
                confirm_lines = [
                    f"Delete folder: {folder['name']}?",
                    "",
                    "Press 'y' to confirm, any other key to cancel"
                ]
                
                self.show_message_box("CONFIRM DELETE", confirm_lines, wait_for_key=False)
                confirm_key = self.stdscr.getch()
                
                if confirm_key in [ord('y'), ord('Y')]:
                    try:
                        shutil.rmtree(folder['path'])
                        self.message = f"Deleted: {folder['name']}"
                        self.message_color = curses.COLOR_GREEN
                        self.load_directory()
                    except Exception as e:
                        self.message = f"Error: {e}"
                        self.message_color = curses.COLOR_RED
                break
            elif key == ord('q'):
                break
    
    def run(self):
        """Main loop"""
        while self.running:
            self.draw()
            
            key = self.stdscr.getch()
            
            # Clear message on any key
            if self.message:
                self.message = ""
            
            if key == curses.KEY_UP:
                self.selected_index = max(0, self.selected_index - 1)
            
            elif key == curses.KEY_DOWN:
                self.selected_index = min(len(self.entries) - 1, self.selected_index + 1)
            
            elif key in [ord('\n'), curses.KEY_ENTER, 10, 13]:
                self.handle_enter()
            
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                # Go up one directory
                if self.current_dir != self.current_dir.parent:
                    self.change_directory(self.current_dir.parent)
            
            elif key == ord('h'):
                # Go to home
                self.change_directory(Path.home())
            
            elif key == ord('r'):
                # Go to root
                self.change_directory(Path("/"))
            
            elif key == ord('?'):
                # Toggle help
                self.show_help = not self.show_help
            
            elif key == ord('q'):
                # Quit
                self.running = False
            
            elif key == ord('b'):
                # Bookmarks
                self.show_bookmarks_menu()
            
            elif key == ord('p'):
                # Fix permissions
                self.fix_permissions()
            
            elif key == ord('e'):
                # Extract archives
                self.extract_archives()
            
            elif key == ord('f'):
                # Find empty folders
                self.find_empty_folders()


class AudioInspector:
    """Audio file quality inspector with comparison capabilities"""
    
    def __init__(self, stdscr, filepath, file_manager=None):
        self.stdscr = stdscr
        self.filepath = Path(filepath)
        self.file_manager = file_manager
        self.running = True
        self.message = ""
        self.message_color = curses.COLOR_GREEN
        self.audio_info = None
        self.compare_file = None
        self.compare_info = None
        self.show_comparison = False
        
        # Initialize colors
        curses.start_color()
        curses.use_default_colors()
        
        # Initialize color pairs needed by inspector
        curses.init_pair(2, curses.COLOR_GREEN, -1)     # High quality values
        curses.init_pair(7, curses.COLOR_BLACK, curses.COLOR_CYAN)  # Headers
        curses.init_pair(8, curses.COLOR_GREEN, -1)     # Success
        curses.init_pair(9, curses.COLOR_RED, -1)       # Error
        curses.init_pair(10, curses.COLOR_YELLOW, -1)   # Warning
        curses.init_pair(11, curses.COLOR_BLUE, -1)     # Info
        curses.init_pair(26, curses.COLOR_WHITE, -1)    # Normal text
        
        # Analyze current file
        self.analyze_file(self.filepath)
    
    def check_ffprobe(self):
        """Check if ffprobe is available"""
        return shutil.which('ffprobe') is not None
    
    def analyze_file(self, filepath):
        """Analyze audio file using ffprobe"""
        if not self.check_ffprobe():
            return {
                'error': 'ffprobe not installed',
                'message': 'Install ffmpeg: sudo apt install ffmpeg'
            }
        
        def safe_int(value, default=0):
            """Safely convert value to int"""
            if value is None or value == '':
                return default
            try:
                return int(float(str(value)))
            except (ValueError, TypeError):
                return default
        
        def safe_float(value, default=0.0):
            """Safely convert value to float"""
            if value is None or value == '':
                return default
            try:
                return float(str(value))
            except (ValueError, TypeError):
                return default
        
        try:
            # Run ffprobe to get audio information
            cmd = [
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_format',
                '-show_streams',
                str(filepath)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode != 0:
                return {'error': f'Failed to analyze file (exit code {result.returncode})'}
            
            if not result.stdout.strip():
                return {'error': 'ffprobe returned no data'}
            
            import json
            try:
                data = json.loads(result.stdout)
            except json.JSONDecodeError as e:
                return {'error': f'Invalid ffprobe output: {str(e)}'}
            
            # Extract audio stream info
            audio_stream = None
            for stream in data.get('streams', []):
                if stream.get('codec_type') == 'audio':
                    audio_stream = stream
                    break
            
            if not audio_stream:
                return {'error': 'No audio stream found in file'}
            
            # Extract format info
            format_info = data.get('format', {})
            
            # Get basic properties with safe conversion
            file_size = safe_int(format_info.get('size'), 0)
            duration = safe_float(format_info.get('duration'), 0.0)
            
            # If duration not in format, try audio stream
            if duration == 0:
                duration = safe_float(audio_stream.get('duration'), 0.0)
            
            # Extract bitrate with fallback calculation
            stream_bitrate = audio_stream.get('bit_rate')
            format_bitrate = format_info.get('bit_rate')
            
            # Determine bitrate and source
            if stream_bitrate is not None and str(stream_bitrate).strip() != '':
                bit_rate = safe_int(stream_bitrate, 0)
                bitrate_source = 'stream'
            elif format_bitrate is not None and str(format_bitrate).strip() != '':
                bit_rate = safe_int(format_bitrate, 0)
                bitrate_source = 'format'
            elif file_size > 0 and duration > 0:
                bit_rate = int((file_size * 8) / duration)
                bitrate_source = 'calculated'
            else:
                bit_rate = 0
                bitrate_source = 'unavailable'
            
            # Build comprehensive audio info
            info = {
                'filepath': filepath,
                'filename': Path(filepath).name,
                'file_size': file_size,
                'duration': duration,
                'format_name': format_info.get('format_name', 'Unknown'),
                'codec': audio_stream.get('codec_name', 'Unknown'),
                'codec_long': audio_stream.get('codec_long_name', 'Unknown'),
                'sample_rate': safe_int(audio_stream.get('sample_rate'), 0),
                'bit_rate': bit_rate,
                'bitrate_source': bitrate_source,
                'channels': safe_int(audio_stream.get('channels'), 0),
                'channel_layout': audio_stream.get('channel_layout', 'Unknown'),
                'bit_depth': audio_stream.get('bits_per_sample', audio_stream.get('bits_per_raw_sample', 'N/A')),
                'bits_per_sample': audio_stream.get('bits_per_sample', 'N/A'),
                'tags': format_info.get('tags', {}),
            }
            
            return info
            
        except subprocess.TimeoutExpired:
            return {'error': 'Analysis timeout (file too large or slow disk)'}
        except Exception as e:
            return {'error': f'Analysis failed: {type(e).__name__}: {str(e)}'}
    
    def get_quality_score(self, info):
        """Calculate quality score (0-100) based on audio metrics"""
        if 'error' in info:
            return 0
        
        score = 0
        
        # Sample rate scoring (max 30 points)
        sample_rate = info.get('sample_rate', 0)
        if sample_rate >= 192000:
            score += 30
        elif sample_rate >= 96000:
            score += 28
        elif sample_rate >= 48000:
            score += 25
        elif sample_rate >= 44100:
            score += 20
        else:
            score += 10
        
        # Bitrate scoring (max 35 points)
        bit_rate = info.get('bit_rate', 0)
        if bit_rate >= 1411000:  # CD quality or higher
            score += 35
        elif bit_rate >= 320000:
            score += 30
        elif bit_rate >= 256000:
            score += 25
        elif bit_rate >= 192000:
            score += 20
        elif bit_rate >= 128000:
            score += 15
        else:
            score += 5
        
        # Bit depth scoring (max 20 points)
        bit_depth = info.get('bit_depth', 'N/A')
        if bit_depth != 'N/A':
            try:
                depth = int(bit_depth)
                if depth >= 24:
                    score += 20
                elif depth >= 16:
                    score += 15
                else:
                    score += 10
            except:
                score += 5
        
        # Codec scoring (max 15 points)
        codec = info.get('codec', '').lower()
        if codec in ['flac', 'alac', 'ape', 'wav']:
            score += 15  # Lossless
        elif codec in ['aac', 'opus', 'vorbis']:
            score += 10  # Good lossy
        elif codec == 'mp3':
            score += 8
        else:
            score += 5
        
        return min(100, score)
    
    def get_quality_label(self, score):
        """Get quality label and color from score"""
        if score >= 90:
            return "Exceptional", curses.color_pair(2)  # Green
        elif score >= 75:
            return "Excellent", curses.color_pair(2)
        elif score >= 60:
            return "Very Good", curses.color_pair(11)  # Blue
        elif score >= 45:
            return "Good", curses.color_pair(10)  # Yellow
        elif score >= 30:
            return "Fair", curses.color_pair(10)
        else:
            return "Poor", curses.color_pair(9)  # Red
    
    def format_size(self, size_bytes):
        """Format bytes to human readable"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} TB"
    
    def format_duration(self, seconds):
        """Format duration to MM:SS or HH:MM:SS"""
        if seconds < 0:
            return "00:00"
        
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        
        if hours > 0:
            return f"{hours:02d}:{minutes:02d}:{secs:02d}"
        else:
            return f"{minutes:02d}:{secs:02d}"
    
    def format_bitrate(self, bitrate):
        """Format bitrate to kbps"""
        if bitrate < 1000:
            return f"{bitrate} bps"
        return f"{bitrate / 1000:.0f} kbps"
    
    def draw_header(self):
        """Draw header"""
        height, width = self.stdscr.getmaxyx()
        
        # Title
        if self.show_comparison:
            title = " üéµ AUDIO QUALITY COMPARISON üéµ "
        else:
            title = " üéµ AUDIO QUALITY INSPECTOR üéµ "
        
        self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
        self.stdscr.addstr(0, 0, title.center(width)[:width])
        self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
        
        # Separator
        self.stdscr.addstr(1, 0, "‚îÄ" * width)
    
    def draw_footer(self):
        """Draw footer with help"""
        height, width = self.stdscr.getmaxyx()
        
        # Separator
        self.stdscr.addstr(height - 4, 0, "‚îÄ" * width)
        
        # Legend for data sources
        legend = "[S]=Stream [F]=Format [C]=Calculated"
        self.stdscr.addstr(height - 3, 1, legend[:width-2], curses.color_pair(10))
        
        # Help text
        if self.show_comparison:
            help_text = "c: Clear Comparison | q: Back to Inspector | ESC: Exit"
        else:
            help_text = "c: Compare with Another File | q/ESC: Exit"
        
        self.stdscr.addstr(height - 2, 1, help_text[:width-2], curses.color_pair(11))
        
        # Message
        if self.message:
            color = curses.color_pair(8) if self.message_color == curses.COLOR_GREEN else \
                    curses.color_pair(9) if self.message_color == curses.COLOR_RED else \
                    curses.color_pair(10)
            self.stdscr.addstr(height - 1, 1, self.message[:width-2], color | curses.A_BOLD)
    
    def draw_audio_info(self, info, start_y, start_x, width, label=None):
        """Draw audio information panel"""
        if 'error' in info:
            self.stdscr.addstr(start_y, start_x, f"‚ùå {info['error']}", curses.color_pair(9))
            if 'message' in info:
                self.stdscr.addstr(start_y + 1, start_x, info['message'], curses.color_pair(10))
            return start_y + 3
        
        current_y = start_y
        
        # File label if provided
        if label:
            self.stdscr.addstr(current_y, start_x, label, curses.color_pair(7) | curses.A_BOLD)
            current_y += 1
        
        # Filename
        filename = info['filename']
        if len(filename) > width - 6:
            filename = filename[:width-9] + "..."
        self.stdscr.addstr(current_y, start_x, f"üìÑ {filename}", curses.color_pair(11) | curses.A_BOLD)
        current_y += 2
        
        # Quality Score
        score = self.get_quality_score(info)
        quality_label, quality_color = self.get_quality_label(score)
        self.stdscr.addstr(current_y, start_x, "Quality Score:", curses.A_BOLD)
        self.stdscr.addstr(current_y, start_x + 16, f"{score}/100 ({quality_label})", quality_color | curses.A_BOLD)
        current_y += 2
        
        # File Size
        self.stdscr.addstr(current_y, start_x, "File Size:")
        self.stdscr.addstr(current_y, start_x + 16, self.format_size(info['file_size']), curses.color_pair(26))
        current_y += 1
        
        # Duration
        self.stdscr.addstr(current_y, start_x, "Duration:")
        self.stdscr.addstr(current_y, start_x + 16, self.format_duration(info['duration']), curses.color_pair(26))
        current_y += 1
        
        # Format
        self.stdscr.addstr(current_y, start_x, "Format:")
        self.stdscr.addstr(current_y, start_x + 16, info['format_name'].upper(), curses.color_pair(26))
        current_y += 1
        
        # Codec
        self.stdscr.addstr(current_y, start_x, "Codec:")
        codec_display = info['codec'].upper()
        codec_color = curses.color_pair(2) if info['codec'].lower() in ['flac', 'alac', 'ape', 'wav'] else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, codec_display, codec_color)
        current_y += 1
        
        # Sample Rate
        self.stdscr.addstr(current_y, start_x, "Sample Rate:")
        sr_display = f"{info['sample_rate']:,} Hz"
        sr_color = curses.color_pair(2) if info['sample_rate'] >= 48000 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, sr_display, sr_color)
        current_y += 1
        
        # Bitrate
        self.stdscr.addstr(current_y, start_x, "Bitrate:")
        br_display = self.format_bitrate(info['bit_rate'])
        
        # Add source indicator (ASCII for terminal compatibility)
        source = info.get('bitrate_source', 'unknown')
        if source == 'stream':
            br_display += " [S]"
        elif source == 'calculated':
            br_display += " [C]"
        elif source == 'format':
            br_display += " [F]"
        else:
            br_display += " [?]"
        
        br_color = curses.color_pair(2) if info['bit_rate'] >= 320000 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, br_display, br_color)
        current_y += 1
        
        # Bit Depth
        self.stdscr.addstr(current_y, start_x, "Bit Depth:")
        bd_display = str(info['bit_depth']) if info['bit_depth'] != 'N/A' else 'N/A'
        if bd_display != 'N/A':
            bd_display += " bit"
        bd_color = curses.color_pair(2) if bd_display != 'N/A' and int(info['bit_depth']) >= 16 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, bd_display, bd_color)
        current_y += 1
        
        # Channels
        self.stdscr.addstr(current_y, start_x, "Channels:")
        ch_display = f"{info['channels']} ({info['channel_layout']})"
        self.stdscr.addstr(current_y, start_x + 16, ch_display, curses.color_pair(26))
        current_y += 1
        
        return current_y
    
    def draw_comparison(self):
        """Draw comparison view"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate panel width
        panel_width = (width - 4) // 2
        
        # Draw left panel (original file)
        left_x = 2
        current_y = self.draw_audio_info(self.audio_info, 3, left_x, panel_width, "FILE 1 (Current)")
        
        # Draw separator
        sep_x = panel_width + 2
        for y in range(2, height - 3):
            self.stdscr.addstr(y, sep_x, "‚îÇ", curses.color_pair(11))
        
        # Draw right panel (comparison file)
        right_x = sep_x + 2
        current_y = self.draw_audio_info(self.compare_info, 3, right_x, panel_width, "FILE 2 (Compare)")
        
        # Draw winner indicator
        if 'error' not in self.audio_info and 'error' not in self.compare_info:
            score1 = self.get_quality_score(self.audio_info)
            score2 = self.get_quality_score(self.compare_info)
            
            winner_y = max(current_y, height - 10)
            if winner_y < height - 4:
                self.stdscr.addstr(winner_y, 0, "‚îÄ" * width)
                winner_y += 1
                
                if score1 > score2:
                    msg = f"üèÜ FILE 1 IS HIGHER QUALITY (by {score1 - score2} points)"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(2) | curses.A_BOLD)
                    winner_y += 1
                    self.stdscr.addstr(winner_y, (width - 30) // 2, "Recommendation: Keep File 1", curses.color_pair(11))
                elif score2 > score1:
                    msg = f"üèÜ FILE 2 IS HIGHER QUALITY (by {score2 - score1} points)"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(2) | curses.A_BOLD)
                    winner_y += 1
                    self.stdscr.addstr(winner_y, (width - 30) // 2, "Recommendation: Keep File 2", curses.color_pair(11))
                else:
                    msg = "‚öñÔ∏è  BOTH FILES HAVE EQUAL QUALITY"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(10) | curses.A_BOLD)
    
    def draw_single_view(self):
        """Draw single file view"""
        height, width = self.stdscr.getmaxyx()
        
        # Center the info panel
        panel_width = min(60, width - 4)
        start_x = (width - panel_width) // 2
        
        self.draw_audio_info(self.audio_info, 3, start_x, panel_width)
    
    def draw(self):
        """Draw the inspector interface"""
        self.stdscr.clear()
        self.draw_header()
        
        if self.show_comparison and self.compare_info:
            self.draw_comparison()
        else:
            self.draw_single_view()
        
        self.draw_footer()
        self.stdscr.refresh()
    
    def browse_for_comparison(self):
        """Browse for a file to compare"""
        if not self.file_manager:
            self.message = "File browser not available"
            self.message_color = curses.COLOR_RED
            return
        
        # Show message
        self.message = "Navigate to comparison file and press Enter, or ESC to cancel"
        self.message_color = curses.COLOR_YELLOW
        self.draw()
        self.stdscr.getch()
        
        # Temporarily return to file manager for selection
        curses.curs_set(0)
        
        # Create message showing the first file being compared
        first_file_name = self.filepath.name
        first_file_path = str(self.filepath.parent)
        
        # Truncate path if too long
        height, width = self.stdscr.getmaxyx()
        max_path_len = width - 60  # Leave room for the message text
        if len(first_file_path) > max_path_len:
            first_file_path = "..." + first_file_path[-(max_path_len-3):]
        
        comparison_msg = f"Comparing FROM: {first_file_name} ({first_file_path})"
        
        while True:
            # Update message each iteration to show first file info
            self.file_manager.message = f"{comparison_msg} | Select 2nd audio file (Enter) or q to cancel"
            self.file_manager.message_color = curses.COLOR_YELLOW
            
            self.file_manager.draw()
            key = self.stdscr.getch()
            
            if key == ord('q') or key == 27:  # q or ESC
                self.message = "Comparison cancelled"
                self.message_color = curses.COLOR_YELLOW
                self.file_manager.message = ""  # Clear the comparison message
                return
            
            elif key == curses.KEY_UP:
                self.file_manager.selected_index = max(0, self.file_manager.selected_index - 1)
            
            elif key == curses.KEY_DOWN:
                self.file_manager.selected_index = min(len(self.file_manager.entries) - 1, 
                                                       self.file_manager.selected_index + 1)
            
            elif key in [ord('\n'), curses.KEY_ENTER, 10, 13]:
                # Check if selected file is audio
                entry = self.file_manager.entries[self.file_manager.selected_index]
                
                if entry['is_dir']:
                    # Navigate into directory
                    self.file_manager.change_directory(entry['path'])
                elif self.file_manager.is_audio_file(entry['path']):
                    # Selected an audio file
                    self.compare_file = entry['path']
                    self.compare_info = self.analyze_file(self.compare_file)
                    self.show_comparison = True
                    self.message = "Comparison loaded!"
                    self.message_color = curses.COLOR_GREEN
                    self.file_manager.message = ""  # Clear the comparison message
                    return
                else:
                    # Keep showing the comparison_msg but add error
                    self.file_manager.message = f"{comparison_msg} | ERROR: Please select an audio file"
                    self.file_manager.message_color = curses.COLOR_RED
            
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                # Go up one directory
                if self.file_manager.current_dir != self.file_manager.current_dir.parent:
                    self.file_manager.change_directory(self.file_manager.current_dir.parent)
    
    def run(self):
        """Main inspector loop"""
        self.audio_info = self.analyze_file(self.filepath)
        curses.curs_set(0)
        
        while self.running:
            self.draw()
            key = self.stdscr.getch()
            
            if key in [ord('q'), 27]:  # q or ESC
                if self.show_comparison:
                    # If in comparison mode, go back to single view
                    self.show_comparison = False
                    self.compare_file = None
                    self.compare_info = None
                    self.message = ""
                else:
                    # Exit inspector
                    self.running = False
            
            elif key == ord('c'):
                if self.show_comparison:
                    # Clear comparison
                    self.show_comparison = False
                    self.compare_file = None
                    self.compare_info = None
                    self.message = "Comparison cleared"
                    self.message_color = curses.COLOR_GREEN
                else:
                    # Start comparison
                    self.browse_for_comparison()


class VideoInspector:
    """Video file quality inspector with comparison capabilities"""
    
    def __init__(self, stdscr, filepath, file_manager=None):
        self.stdscr = stdscr
        self.filepath = Path(filepath)
        self.file_manager = file_manager
        self.running = True
        self.message = ""
        self.message_color = curses.COLOR_GREEN
        self.video_info = None
        self.compare_file = None
        self.compare_info = None
        self.show_comparison = False
        
        # Initialize colors
        curses.start_color()
        curses.use_default_colors()
        
        # Initialize color pairs needed by inspector
        curses.init_pair(2, curses.COLOR_GREEN, -1)     # High quality values
        curses.init_pair(7, curses.COLOR_BLACK, curses.COLOR_CYAN)  # Headers
        curses.init_pair(8, curses.COLOR_GREEN, -1)     # Success
        curses.init_pair(9, curses.COLOR_RED, -1)       # Error
        curses.init_pair(10, curses.COLOR_YELLOW, -1)   # Warning
        curses.init_pair(11, curses.COLOR_BLUE, -1)     # Info
        curses.init_pair(26, curses.COLOR_WHITE, -1)    # Normal text
        
        # Analyze current file
        self.analyze_file(self.filepath)
    
    def check_ffprobe(self):
        """Check if ffprobe is available"""
        return shutil.which('ffprobe') is not None
    
    def analyze_file(self, filepath):
        """Analyze video file using ffprobe"""
        if not self.check_ffprobe():
            return {
                'error': 'ffprobe not installed',
                'message': 'Install ffmpeg: sudo apt install ffmpeg'
            }
        
        def safe_int(value, default=0):
            """Safely convert value to int"""
            if value is None or value == '':
                return default
            try:
                return int(float(str(value)))
            except (ValueError, TypeError):
                return default
        
        def safe_float(value, default=0.0):
            """Safely convert value to float"""
            if value is None or value == '':
                return default
            try:
                return float(str(value))
            except (ValueError, TypeError):
                return default
        
        try:
            # Run ffprobe to get video information
            cmd = [
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_format',
                '-show_streams',
                str(filepath)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode != 0:
                return {'error': f'Failed to analyze file (exit code {result.returncode})'}
            
            if not result.stdout.strip():
                return {'error': 'ffprobe returned no data'}
            
            import json
            try:
                data = json.loads(result.stdout)
            except json.JSONDecodeError as e:
                return {'error': f'Invalid ffprobe output: {str(e)}'}
            
            # Extract video and audio streams
            # Skip attached pictures (album art) which are technically video streams
            video_stream = None
            audio_stream = None
            for stream in data.get('streams', []):
                codec_type = stream.get('codec_type', '')
                
                # Check if it's a real video stream, not album art
                if codec_type == 'video' and not video_stream:
                    # Skip if it's an attached picture (album art)
                    disposition = stream.get('disposition', {})
                    if disposition.get('attached_pic', 0) == 1:
                        continue
                    # Skip very small "video" streams that are likely thumbnails
                    width = safe_int(stream.get('width'), 0)
                    height = safe_int(stream.get('height'), 0)
                    if width < 100 or height < 100:
                        continue
                    video_stream = stream
                elif codec_type == 'audio' and not audio_stream:
                    audio_stream = stream
            
            if not video_stream:
                return {'error': 'No video stream found in file'}
            
            # Extract format info
            format_info = data.get('format', {})
            
            # Get basic properties with safe conversion
            file_size = safe_int(format_info.get('size'), 0)
            duration = safe_float(format_info.get('duration'), 0.0)
            
            # If duration not in format, try to get from video stream
            if duration == 0:
                duration = safe_float(video_stream.get('duration'), 0.0)
            
            # Get dimensions
            width = safe_int(video_stream.get('width'), 0)
            height = safe_int(video_stream.get('height'), 0)
            
            # Extract video bitrate with fallback calculation
            video_stream_bitrate = video_stream.get('bit_rate')
            format_bitrate = format_info.get('bit_rate')
            
            # Determine video bitrate and source
            if video_stream_bitrate is not None and str(video_stream_bitrate).strip() != '':
                video_bitrate = safe_int(video_stream_bitrate, 0)
                video_bitrate_source = 'stream'
            elif format_bitrate is not None and str(format_bitrate).strip() != '':
                video_bitrate = safe_int(format_bitrate, 0)
                video_bitrate_source = 'format'
            elif file_size > 0 and duration > 0:
                video_bitrate = int((file_size * 8) / duration)
                video_bitrate_source = 'calculated'
            else:
                video_bitrate = 0
                video_bitrate_source = 'unavailable'
            
            # Extract audio bitrate with fallback
            audio_bitrate = 0
            audio_bitrate_source = 'unavailable'
            if audio_stream:
                audio_stream_bitrate = audio_stream.get('bit_rate')
                if audio_stream_bitrate is not None and str(audio_stream_bitrate).strip() != '':
                    audio_bitrate = safe_int(audio_stream_bitrate, 0)
                    audio_bitrate_source = 'stream'
                    # If video bitrate came from format, subtract audio to get video-only
                    if video_bitrate_source == 'format' and audio_bitrate > 0:
                        video_bitrate = max(0, video_bitrate - audio_bitrate)
                elif duration > 0 and video_bitrate > 0:
                    # Estimate audio bitrate
                    estimated_audio = int(video_bitrate * 0.07)
                    audio_bitrate = min(max(128000, estimated_audio), 320000)
                    audio_bitrate_source = 'estimated'
            
            # Parse frame rate
            fps = self.parse_fps(video_stream.get('r_frame_rate', '0/1'))
            # Fall back to avg_frame_rate if r_frame_rate fails
            if fps == 0:
                fps = self.parse_fps(video_stream.get('avg_frame_rate', '0/1'))
            
            # Build comprehensive video info
            info = {
                'filepath': filepath,
                'filename': Path(filepath).name,
                'file_size': file_size,
                'duration': duration,
                'format_name': format_info.get('format_name', 'Unknown'),
                
                # Video properties
                'video_codec': video_stream.get('codec_name', 'Unknown'),
                'video_codec_long': video_stream.get('codec_long_name', 'Unknown'),
                'width': width,
                'height': height,
                'video_bitrate': video_bitrate,
                'video_bitrate_source': video_bitrate_source,
                'fps': fps,
                'pix_fmt': video_stream.get('pix_fmt', 'Unknown'),
                'color_space': video_stream.get('color_space', 'Unknown'),
                'bit_depth': video_stream.get('bits_per_raw_sample', 'N/A'),
                
                # Audio properties (if available)
                'has_audio': audio_stream is not None,
                'audio_codec': audio_stream.get('codec_name', 'N/A') if audio_stream else 'N/A',
                'audio_bitrate': audio_bitrate,
                'audio_bitrate_source': audio_bitrate_source,
                'audio_sample_rate': safe_int(audio_stream.get('sample_rate'), 0) if audio_stream else 0,
                'audio_channels': safe_int(audio_stream.get('channels'), 0) if audio_stream else 0,
                
                # Overall bitrate
                'total_bitrate': safe_int(format_bitrate, video_bitrate + audio_bitrate),
                
                'tags': format_info.get('tags', {}),
            }
            
            # Calculate resolution category
            info['resolution'] = self.get_resolution_name(info['width'], info['height'])
            
            return info
            
        except subprocess.TimeoutExpired:
            return {'error': 'Analysis timeout (file too large or slow disk)'}
        except Exception as e:
            return {'error': f'Analysis failed: {type(e).__name__}: {str(e)}'}
    
    def parse_fps(self, fps_string):
        """Parse frame rate from fraction string like '30000/1001'"""
        try:
            if '/' in fps_string:
                num, den = fps_string.split('/')
                return float(num) / float(den)
            return float(fps_string)
        except:
            return 0.0
    
    def get_resolution_name(self, width, height):
        """Get common resolution names"""
        if width >= 7680 and height >= 4320:
            return "8K UHD"
        elif width >= 3840 and height >= 2160:
            return "4K UHD (2160p)"
        elif width >= 2560 and height >= 1440:
            return "QHD (1440p)"
        elif width >= 1920 and height >= 1080:
            return "Full HD (1080p)"
        elif width >= 1280 and height >= 720:
            return "HD (720p)"
        elif width >= 854 and height >= 480:
            return "SD (480p)"
        else:
            return f"{width}x{height}"
    
    def get_quality_score(self, info):
        """Calculate quality score (0-100) based on video metrics"""
        if 'error' in info:
            return 0
        
        score = 0
        
        # Resolution scoring (max 35 points)
        pixels = info.get('width', 0) * info.get('height', 0)
        if pixels >= 33177600:  # 8K
            score += 35
        elif pixels >= 8294400:  # 4K
            score += 33
        elif pixels >= 3686400:  # 1440p
            score += 28
        elif pixels >= 2073600:  # 1080p
            score += 25
        elif pixels >= 921600:  # 720p
            score += 18
        else:
            score += 10
        
        # Video bitrate scoring (max 30 points)
        vbitrate = info.get('video_bitrate', info.get('total_bitrate', 0))
        if vbitrate >= 50000000:  # 50 Mbps+
            score += 30
        elif vbitrate >= 20000000:  # 20 Mbps
            score += 28
        elif vbitrate >= 10000000:  # 10 Mbps
            score += 25
        elif vbitrate >= 5000000:  # 5 Mbps
            score += 20
        elif vbitrate >= 2500000:  # 2.5 Mbps
            score += 15
        else:
            score += 8
        
        # Codec scoring (max 20 points)
        codec = info.get('video_codec', '').lower()
        if codec in ['av1']:
            score += 20  # Most modern and efficient
        elif codec in ['hevc', 'h265']:
            score += 18  # Excellent
        elif codec in ['vp9']:
            score += 17  # Very good
        elif codec in ['h264', 'avc']:
            score += 14  # Good standard
        elif codec in ['vp8']:
            score += 12
        else:
            score += 8
        
        # Frame rate scoring (max 15 points)
        fps = info.get('fps', 0)
        if fps >= 120:
            score += 15
        elif fps >= 60:
            score += 14
        elif fps >= 50:
            score += 13
        elif fps >= 29.9:  # 30fps (allow for 29.97)
            score += 11
        elif fps >= 23.9:  # 24fps cinema standard (23.976)
            score += 9
        else:
            score += 5
        
        return min(100, score)
    
    def get_quality_label(self, score):
        """Get quality label and color from score"""
        if score >= 90:
            return "Exceptional", curses.color_pair(2)  # Green
        elif score >= 75:
            return "Excellent", curses.color_pair(2)
        elif score >= 60:
            return "Very Good", curses.color_pair(11)  # Blue
        elif score >= 45:
            return "Good", curses.color_pair(10)  # Yellow
        elif score >= 30:
            return "Fair", curses.color_pair(10)
        else:
            return "Poor", curses.color_pair(9)  # Red
    
    def format_size(self, size_bytes):
        """Format bytes to human readable"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} TB"
    
    def format_duration(self, seconds):
        """Format duration to MM:SS or HH:MM:SS"""
        if seconds < 0:
            return "00:00"
        
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        
        if hours > 0:
            return f"{hours:02d}:{minutes:02d}:{secs:02d}"
        else:
            return f"{minutes:02d}:{secs:02d}"
    
    def format_bitrate(self, bitrate):
        """Format bitrate to Mbps/kbps"""
        if bitrate >= 1000000:
            return f"{bitrate / 1000000:.1f} Mbps"
        elif bitrate >= 1000:
            return f"{bitrate / 1000:.0f} kbps"
        return f"{bitrate} bps"
    
    def draw_header(self):
        """Draw header"""
        height, width = self.stdscr.getmaxyx()
        
        # Title
        if self.show_comparison:
            title = " üé¨ VIDEO QUALITY COMPARISON üé¨ "
        else:
            title = " üé¨ VIDEO QUALITY INSPECTOR üé¨ "
        
        self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
        self.stdscr.addstr(0, 0, title.center(width)[:width])
        self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
        
        # Separator
        self.stdscr.addstr(1, 0, "‚îÄ" * width)
    
    def draw_footer(self):
        """Draw footer with help"""
        height, width = self.stdscr.getmaxyx()
        
        # Separator
        self.stdscr.addstr(height - 4, 0, "‚îÄ" * width)
        
        # Legend for data sources
        legend = "[S]=Stream [F]=Format [C]=Calculated [E]=Estimated"
        self.stdscr.addstr(height - 3, 1, legend[:width-2], curses.color_pair(10))
        
        # Help text
        if self.show_comparison:
            help_text = "c: Clear Comparison | q: Back to Inspector | ESC: Exit"
        else:
            help_text = "c: Compare with Another File | q/ESC: Exit"
        
        self.stdscr.addstr(height - 2, 1, help_text[:width-2], curses.color_pair(11))
        
        # Message
        if self.message:
            color = curses.color_pair(8) if self.message_color == curses.COLOR_GREEN else \
                    curses.color_pair(9) if self.message_color == curses.COLOR_RED else \
                    curses.color_pair(10)
            self.stdscr.addstr(height - 1, 1, self.message[:width-2], color | curses.A_BOLD)
    
    def draw_video_info(self, info, start_y, start_x, width, label=None):
        """Draw video information panel"""
        if 'error' in info:
            self.stdscr.addstr(start_y, start_x, f"‚ùå {info['error']}", curses.color_pair(9))
            if 'message' in info:
                self.stdscr.addstr(start_y + 1, start_x, info['message'], curses.color_pair(10))
            return start_y + 3
        
        current_y = start_y
        
        # File label if provided
        if label:
            self.stdscr.addstr(current_y, start_x, label, curses.color_pair(7) | curses.A_BOLD)
            current_y += 1
        
        # Filename
        filename = info['filename']
        if len(filename) > width - 6:
            filename = filename[:width-9] + "..."
        self.stdscr.addstr(current_y, start_x, f"üé¨ {filename}", curses.color_pair(11) | curses.A_BOLD)
        current_y += 2
        
        # Quality Score
        score = self.get_quality_score(info)
        quality_label, quality_color = self.get_quality_label(score)
        self.stdscr.addstr(current_y, start_x, "Quality Score:", curses.A_BOLD)
        self.stdscr.addstr(current_y, start_x + 16, f"{score}/100 ({quality_label})", quality_color | curses.A_BOLD)
        current_y += 2
        
        # File Size
        self.stdscr.addstr(current_y, start_x, "File Size:")
        self.stdscr.addstr(current_y, start_x + 16, self.format_size(info['file_size']), curses.color_pair(26))
        current_y += 1
        
        # Duration
        self.stdscr.addstr(current_y, start_x, "Duration:")
        self.stdscr.addstr(current_y, start_x + 16, self.format_duration(info['duration']), curses.color_pair(26))
        current_y += 1
        
        # Resolution
        self.stdscr.addstr(current_y, start_x, "Resolution:")
        res_display = f"{info['resolution']}"
        res_color = curses.color_pair(2) if info.get('height', 0) >= 1080 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, res_display, res_color)
        current_y += 1
        
        # Dimensions
        self.stdscr.addstr(current_y, start_x, "Dimensions:")
        dim_display = f"{info['width']}x{info['height']}"
        self.stdscr.addstr(current_y, start_x + 16, dim_display, curses.color_pair(26))
        current_y += 1
        
        # Video Codec
        self.stdscr.addstr(current_y, start_x, "Video Codec:")
        codec_display = info['video_codec'].upper()
        codec_color = curses.color_pair(2) if info['video_codec'].lower() in ['av1', 'hevc', 'h265'] else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, codec_display, codec_color)
        current_y += 1
        
        # Video Bitrate
        self.stdscr.addstr(current_y, start_x, "Video Bitrate:")
        vbitrate = info.get('video_bitrate', info.get('total_bitrate', 0))
        br_display = self.format_bitrate(vbitrate)
        
        # Add source indicator (ASCII for terminal compatibility)
        source = info.get('video_bitrate_source', 'unknown')
        if source == 'stream':
            br_display += " [S]"
        elif source == 'calculated':
            br_display += " [C]"
        elif source == 'format':
            br_display += " [F]"
        else:
            br_display += " [?]"
        
        br_color = curses.color_pair(2) if vbitrate >= 10000000 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, br_display, br_color)
        current_y += 1
        
        # Frame Rate
        self.stdscr.addstr(current_y, start_x, "Frame Rate:")
        fps_display = f"{info['fps']:.2f} fps"
        fps_color = curses.color_pair(2) if info['fps'] >= 60 else curses.color_pair(26)
        self.stdscr.addstr(current_y, start_x + 16, fps_display, fps_color)
        current_y += 1
        
        # Audio info
        if info['has_audio']:
            self.stdscr.addstr(current_y, start_x, "Audio Codec:")
            self.stdscr.addstr(current_y, start_x + 16, info['audio_codec'].upper(), curses.color_pair(26))
            current_y += 1
            
            if info['audio_bitrate'] > 0:
                self.stdscr.addstr(current_y, start_x, "Audio Bitrate:")
                abr_display = self.format_bitrate(info['audio_bitrate'])
                
                # Add source indicator (ASCII for terminal compatibility)
                source = info.get('audio_bitrate_source', 'unknown')
                if source == 'stream':
                    abr_display += " [S]"
                elif source == 'calculated':
                    abr_display += " [C]"
                elif source == 'estimated':
                    abr_display += " [E]"
                else:
                    abr_display += " [?]"
                
                self.stdscr.addstr(current_y, start_x + 16, abr_display, curses.color_pair(26))
                current_y += 1
        else:
            self.stdscr.addstr(current_y, start_x, "Audio:")
            self.stdscr.addstr(current_y, start_x + 16, "No audio track", curses.color_pair(9))
            current_y += 1
        
        return current_y
    
    def draw_comparison(self):
        """Draw comparison view"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate panel width
        panel_width = (width - 4) // 2
        
        # Draw left panel (original file)
        left_x = 2
        current_y = self.draw_video_info(self.video_info, 3, left_x, panel_width, "FILE 1 (Current)")
        
        # Draw separator
        sep_x = panel_width + 2
        for y in range(2, height - 3):
            self.stdscr.addstr(y, sep_x, "‚îÇ", curses.color_pair(11))
        
        # Draw right panel (comparison file)
        right_x = sep_x + 2
        current_y = self.draw_video_info(self.compare_info, 3, right_x, panel_width, "FILE 2 (Compare)")
        
        # Draw winner indicator
        if 'error' not in self.video_info and 'error' not in self.compare_info:
            score1 = self.get_quality_score(self.video_info)
            score2 = self.get_quality_score(self.compare_info)
            
            winner_y = max(current_y, height - 10)
            if winner_y < height - 4:
                self.stdscr.addstr(winner_y, 0, "‚îÄ" * width)
                winner_y += 1
                
                if score1 > score2:
                    msg = f"üèÜ FILE 1 IS HIGHER QUALITY (by {score1 - score2} points)"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(2) | curses.A_BOLD)
                    winner_y += 1
                    self.stdscr.addstr(winner_y, (width - 30) // 2, "Recommendation: Keep File 1", curses.color_pair(11))
                elif score2 > score1:
                    msg = f"üèÜ FILE 2 IS HIGHER QUALITY (by {score2 - score1} points)"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(2) | curses.A_BOLD)
                    winner_y += 1
                    self.stdscr.addstr(winner_y, (width - 30) // 2, "Recommendation: Keep File 2", curses.color_pair(11))
                else:
                    msg = "‚öñÔ∏è  BOTH FILES HAVE EQUAL QUALITY"
                    self.stdscr.addstr(winner_y, (width - len(msg)) // 2, msg, curses.color_pair(10) | curses.A_BOLD)
    
    def draw_single_view(self):
        """Draw single file view"""
        height, width = self.stdscr.getmaxyx()
        
        # Center the info panel
        panel_width = min(60, width - 4)
        start_x = (width - panel_width) // 2
        
        self.draw_video_info(self.video_info, 3, start_x, panel_width)
    
    def draw(self):
        """Draw the inspector interface"""
        self.stdscr.clear()
        self.draw_header()
        
        if self.show_comparison and self.compare_info:
            self.draw_comparison()
        else:
            self.draw_single_view()
        
        self.draw_footer()
        self.stdscr.refresh()
    
    def browse_for_comparison(self):
        """Browse for a file to compare"""
        if not self.file_manager:
            self.message = "File browser not available"
            self.message_color = curses.COLOR_RED
            return
        
        # Show message
        self.message = "Navigate to comparison file and press Enter, or ESC to cancel"
        self.message_color = curses.COLOR_YELLOW
        self.draw()
        self.stdscr.getch()
        
        # Temporarily return to file manager for selection
        curses.curs_set(0)
        
        # Create message showing the first file being compared
        first_file_name = self.filepath.name
        first_file_path = str(self.filepath.parent)
        
        # Truncate path if too long
        height, width = self.stdscr.getmaxyx()
        max_path_len = width - 60  # Leave room for the message text
        if len(first_file_path) > max_path_len:
            first_file_path = "..." + first_file_path[-(max_path_len-3):]
        
        comparison_msg = f"Comparing FROM: {first_file_name} ({first_file_path})"
        
        while True:
            # Update message each iteration to show first file info
            self.file_manager.message = f"{comparison_msg} | Select 2nd video file (Enter) or q to cancel"
            self.file_manager.message_color = curses.COLOR_YELLOW
            
            self.file_manager.draw()
            key = self.stdscr.getch()
            
            if key == ord('q') or key == 27:  # q or ESC
                self.message = "Comparison cancelled"
                self.message_color = curses.COLOR_YELLOW
                self.file_manager.message = ""  # Clear the comparison message
                return
            
            elif key == curses.KEY_UP:
                self.file_manager.selected_index = max(0, self.file_manager.selected_index - 1)
            
            elif key == curses.KEY_DOWN:
                self.file_manager.selected_index = min(len(self.file_manager.entries) - 1, 
                                                       self.file_manager.selected_index + 1)
            
            elif key in [ord('\n'), curses.KEY_ENTER, 10, 13]:
                # Check if selected file is video
                entry = self.file_manager.entries[self.file_manager.selected_index]
                
                if entry['is_dir']:
                    # Navigate into directory
                    self.file_manager.change_directory(entry['path'])
                elif self.file_manager.is_video_file(entry['path']):
                    # Selected a video file
                    self.compare_file = entry['path']
                    self.compare_info = self.analyze_file(self.compare_file)
                    self.show_comparison = True
                    self.message = "Comparison loaded!"
                    self.message_color = curses.COLOR_GREEN
                    self.file_manager.message = ""  # Clear the comparison message
                    return
                else:
                    # Keep showing the comparison_msg but add error
                    self.file_manager.message = f"{comparison_msg} | ERROR: Please select a video file"
                    self.file_manager.message_color = curses.COLOR_RED
            
            elif key in [curses.KEY_BACKSPACE, 127, 8]:
                # Go up one directory
                if self.file_manager.current_dir != self.file_manager.current_dir.parent:
                    self.file_manager.change_directory(self.file_manager.current_dir.parent)
    
    def run(self):
        """Main inspector loop"""
        self.video_info = self.analyze_file(self.filepath)
        curses.curs_set(0)
        
        while self.running:
            self.draw()
            key = self.stdscr.getch()
            
            if key in [ord('q'), 27]:  # q or ESC
                if self.show_comparison:
                    # If in comparison mode, go back to single view
                    self.show_comparison = False
                    self.compare_file = None
                    self.compare_info = None
                    self.message = ""
                else:
                    # Exit inspector
                    self.running = False
            
            elif key == ord('c'):
                if self.show_comparison:
                    # Clear comparison
                    self.show_comparison = False
                    self.compare_file = None
                    self.compare_info = None
                    self.message = "Comparison cleared"
                    self.message_color = curses.COLOR_GREEN
                else:
                    # Start comparison
                    self.browse_for_comparison()


class TextEditor:
    """Built-in text editor with syntax highlighting and advanced features"""
    
    def __init__(self, stdscr, filepath):
        self.stdscr = stdscr
        self.filepath = Path(filepath)
        self.lines = []
        self.cursor_x = 0
        self.cursor_y = 0
        self.scroll_offset_x = 0
        self.scroll_offset_y = 0
        self.modified = False
        self.running = True
        self.message = ""
        self.message_color = curses.COLOR_GREEN
        self.clipboard = []
        self.selection_mode = False
        self.tab_size = 4
        
        # Initialize colors for syntax highlighting
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(20, curses.COLOR_GREEN, -1)    # Strings
        curses.init_pair(21, curses.COLOR_BLUE, -1)     # Keywords
        curses.init_pair(22, curses.COLOR_CYAN, -1)     # Comments
        curses.init_pair(23, curses.COLOR_YELLOW, -1)   # Numbers
        curses.init_pair(24, curses.COLOR_MAGENTA, -1)  # Special
        curses.init_pair(25, curses.COLOR_RED, -1)      # Errors
        curses.init_pair(26, curses.COLOR_WHITE, -1)    # Normal
        
        # Load file
        self.load_file()
    
    def load_file(self):
        """Load file contents"""
        try:
            if self.filepath.exists():
                with open(self.filepath, 'r', encoding='utf-8', errors='replace') as f:
                    self.lines = f.read().splitlines()
                if not self.lines:
                    self.lines = ['']
                self.message = f"Loaded: {self.filepath.name}"
                self.message_color = curses.COLOR_GREEN
            else:
                self.lines = ['']
                self.message = f"New file: {self.filepath.name}"
                self.message_color = curses.COLOR_YELLOW
        except Exception as e:
            self.lines = ['']
            self.message = f"Error loading file: {e}"
            self.message_color = curses.COLOR_RED
    
    def save_file(self):
        """Save file contents"""
        try:
            with open(self.filepath, 'w', encoding='utf-8') as f:
                f.write('\n'.join(self.lines))
            self.modified = False
            self.message = f"Saved: {self.filepath.name}"
            self.message_color = curses.COLOR_GREEN
            return True
        except Exception as e:
            self.message = f"Error saving: {e}"
            self.message_color = curses.COLOR_RED
            return False
    
    def get_line_number_width(self):
        """Calculate width needed for line numbers"""
        return len(str(len(self.lines))) + 2
    
    def draw_header(self):
        """Draw header with file info"""
        height, width = self.stdscr.getmaxyx()
        
        # Title bar
        title = f" üìù TEXT EDITOR - {self.filepath.name} "
        if self.modified:
            title += "[Modified] "
        
        self.stdscr.attron(curses.color_pair(7) | curses.A_BOLD)
        self.stdscr.addstr(0, 0, title.center(width)[:width])
        self.stdscr.attroff(curses.color_pair(7) | curses.A_BOLD)
        
        # Cursor position
        pos_str = f"Line {self.cursor_y + 1}/{len(self.lines)} Col {self.cursor_x + 1}"
        self.stdscr.addstr(1, 1, pos_str[:width-2], curses.color_pair(11))
        
        # File path
        path_str = f"üìÅ {self.filepath}"
        if len(path_str) > width - 2:
            path_str = "üìÅ ..." + path_str[-(width-6):]
        self.stdscr.addstr(1, width - len(pos_str) - 2, pos_str, curses.color_pair(11))
        
        # Separator
        self.stdscr.addstr(2, 0, "‚îÄ" * width)
    
    def draw_footer(self):
        """Draw footer with help"""
        height, width = self.stdscr.getmaxyx()
        
        # Separator
        self.stdscr.addstr(height - 3, 0, "‚îÄ" * width)
        
        # Help text
        help_text = "^S:Save ^Q:Quit ^A:SelectAll ^C:Copy ^V:Paste ^D:DeleteAll ^X:ForceQuit"
        self.stdscr.addstr(height - 2, 1, help_text[:width-2], curses.color_pair(11))
        
        # Message
        if self.message:
            color = curses.color_pair(8) if self.message_color == curses.COLOR_GREEN else \
                    curses.color_pair(9) if self.message_color == curses.COLOR_RED else \
                    curses.color_pair(10)
            self.stdscr.addstr(height - 1, 1, self.message[:width-2], color | curses.A_BOLD)
    
    def get_syntax_color(self, line, col):
        """Get syntax highlighting color for character (basic implementation)"""
        if not line:
            return curses.color_pair(26)
        
        # Detect file type
        ext = self.filepath.suffix.lower()
        
        # Python syntax
        if ext == '.py':
            # Check for comments
            if '#' in line:
                comment_pos = line.find('#')
                if col >= comment_pos:
                    return curses.color_pair(22)
            
            # Check for strings
            in_string = False
            quote_char = None
            for i in range(min(col + 1, len(line))):
                if line[i] in ['"', "'"] and (i == 0 or line[i-1] != '\\'):
                    if not in_string:
                        in_string = True
                        quote_char = line[i]
                    elif line[i] == quote_char:
                        in_string = False
            
            if in_string:
                return curses.color_pair(20)
            
            # Check for keywords
            keywords = {'def', 'class', 'import', 'from', 'if', 'else', 'elif', 
                       'for', 'while', 'return', 'try', 'except', 'with', 'as',
                       'True', 'False', 'None', 'and', 'or', 'not', 'in', 'is'}
            
            # Get word at cursor
            start = col
            while start > 0 and (line[start-1].isalnum() or line[start-1] == '_'):
                start -= 1
            end = col
            while end < len(line) and (line[end].isalnum() or line[end] == '_'):
                end += 1
            
            word = line[start:end]
            if word in keywords:
                return curses.color_pair(21)
        
        # JSON syntax
        elif ext == '.json':
            if '"' in line:
                in_string = False
                for i in range(min(col + 1, len(line))):
                    if line[i] == '"' and (i == 0 or line[i-1] != '\\'):
                        in_string = not in_string
                if in_string:
                    return curses.color_pair(20)
        
        return curses.color_pair(26)
    
    def draw_content(self):
        """Draw file content with line numbers"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate visible area
        content_start_y = 3
        content_end_y = height - 3
        visible_lines = content_end_y - content_start_y
        
        line_num_width = self.get_line_number_width()
        
        # Adjust scroll offset
        if self.cursor_y < self.scroll_offset_y:
            self.scroll_offset_y = self.cursor_y
        elif self.cursor_y >= self.scroll_offset_y + visible_lines:
            self.scroll_offset_y = self.cursor_y - visible_lines + 1
        
        # Draw lines
        for i in range(visible_lines):
            line_index = i + self.scroll_offset_y
            y_pos = content_start_y + i
            
            if line_index >= len(self.lines):
                # Draw empty line number area
                self.stdscr.addstr(y_pos, 0, " " * line_num_width, curses.color_pair(11) | curses.A_DIM)
                continue
            
            line = self.lines[line_index]
            
            # Draw line number
            line_num_str = f"{line_index + 1:>{line_num_width - 1}} "
            if line_index == self.cursor_y:
                self.stdscr.addstr(y_pos, 0, line_num_str, curses.color_pair(11) | curses.A_BOLD)
            else:
                self.stdscr.addstr(y_pos, 0, line_num_str, curses.color_pair(11) | curses.A_DIM)
            
            # Adjust horizontal scroll
            content_width = width - line_num_width - 1
            if self.cursor_y == line_index:
                if self.cursor_x < self.scroll_offset_x:
                    self.scroll_offset_x = self.cursor_x
                elif self.cursor_x >= self.scroll_offset_x + content_width:
                    self.scroll_offset_x = self.cursor_x - content_width + 1
            
            # Draw line content
            visible_line = line[self.scroll_offset_x:self.scroll_offset_x + content_width]
            
            # Simple syntax highlighting
            try:
                for col_idx, char in enumerate(visible_line):
                    actual_col = col_idx + self.scroll_offset_x
                    color = self.get_syntax_color(line, actual_col)
                    self.stdscr.addstr(y_pos, line_num_width + col_idx, char, color)
            except:
                # Fallback without syntax highlighting
                self.stdscr.addstr(y_pos, line_num_width, visible_line[:content_width])
        
        # Position cursor
        screen_y = content_start_y + (self.cursor_y - self.scroll_offset_y)
        screen_x = line_num_width + (self.cursor_x - self.scroll_offset_x)
        
        if (0 <= self.cursor_y < len(self.lines) and 
            content_start_y <= screen_y < content_end_y and
            line_num_width <= screen_x < width):
            try:
                curses.curs_set(1)
                self.stdscr.move(screen_y, screen_x)
            except:
                curses.curs_set(0)
        else:
            curses.curs_set(0)
    
    def draw(self):
        """Draw the entire editor"""
        self.stdscr.clear()
        self.draw_header()
        self.draw_content()
        self.draw_footer()
        self.stdscr.refresh()
    
    def insert_char(self, char):
        """Insert character at cursor position"""
        line = self.lines[self.cursor_y]
        self.lines[self.cursor_y] = line[:self.cursor_x] + char + line[self.cursor_x:]
        self.cursor_x += 1
        self.modified = True
    
    def delete_char(self):
        """Delete character before cursor (Backspace)"""
        if self.cursor_x > 0:
            line = self.lines[self.cursor_y]
            self.lines[self.cursor_y] = line[:self.cursor_x-1] + line[self.cursor_x:]
            self.cursor_x -= 1
            self.modified = True
        elif self.cursor_y > 0:
            # Join with previous line
            current_line = self.lines[self.cursor_y]
            self.cursor_y -= 1
            self.cursor_x = len(self.lines[self.cursor_y])
            self.lines[self.cursor_y] += current_line
            del self.lines[self.cursor_y + 1]
            self.modified = True
    
    def delete_char_forward(self):
        """Delete character at cursor (Delete key)"""
        line = self.lines[self.cursor_y]
        if self.cursor_x < len(line):
            self.lines[self.cursor_y] = line[:self.cursor_x] + line[self.cursor_x+1:]
            self.modified = True
        elif self.cursor_y < len(self.lines) - 1:
            # Join with next line
            self.lines[self.cursor_y] += self.lines[self.cursor_y + 1]
            del self.lines[self.cursor_y + 1]
            self.modified = True
    
    def insert_newline(self):
        """Insert newline at cursor position"""
        line = self.lines[self.cursor_y]
        self.lines[self.cursor_y] = line[:self.cursor_x]
        self.lines.insert(self.cursor_y + 1, line[self.cursor_x:])
        self.cursor_y += 1
        self.cursor_x = 0
        self.modified = True
    
    def move_cursor(self, dx, dy):
        """Move cursor by delta"""
        # Move vertically
        self.cursor_y = max(0, min(len(self.lines) - 1, self.cursor_y + dy))
        
        # Move horizontally
        max_x = len(self.lines[self.cursor_y])
        self.cursor_x = max(0, min(max_x, self.cursor_x + dx))
    
    def page_up(self):
        """Move up one page"""
        height, width = self.stdscr.getmaxyx()
        page_size = height - 6
        self.cursor_y = max(0, self.cursor_y - page_size)
        self.cursor_x = min(self.cursor_x, len(self.lines[self.cursor_y]))
    
    def page_down(self):
        """Move down one page"""
        height, width = self.stdscr.getmaxyx()
        page_size = height - 6
        self.cursor_y = min(len(self.lines) - 1, self.cursor_y + page_size)
        self.cursor_x = min(self.cursor_x, len(self.lines[self.cursor_y]))
    
    def select_all(self):
        """Copy all text to clipboard"""
        self.clipboard = self.lines.copy()
        self.message = f"Copied {len(self.lines)} lines to clipboard"
        self.message_color = curses.COLOR_GREEN
    
    def copy_line(self):
        """Copy current line to clipboard"""
        self.clipboard = [self.lines[self.cursor_y]]
        self.message = "Copied current line"
        self.message_color = curses.COLOR_GREEN
    
    def paste(self):
        """Paste clipboard contents"""
        if not self.clipboard:
            self.message = "Clipboard is empty"
            self.message_color = curses.COLOR_YELLOW
            return
        
        if len(self.clipboard) == 1:
            # Paste single line at cursor
            line = self.lines[self.cursor_y]
            self.lines[self.cursor_y] = line[:self.cursor_x] + self.clipboard[0] + line[self.cursor_x:]
            self.cursor_x += len(self.clipboard[0])
        else:
            # Paste multiple lines
            line = self.lines[self.cursor_y]
            before = line[:self.cursor_x]
            after = line[self.cursor_x:]
            
            # First line
            self.lines[self.cursor_y] = before + self.clipboard[0]
            
            # Middle lines
            for i in range(1, len(self.clipboard) - 1):
                self.lines.insert(self.cursor_y + i, self.clipboard[i])
            
            # Last line
            if len(self.clipboard) > 1:
                self.lines.insert(self.cursor_y + len(self.clipboard) - 1, 
                                self.clipboard[-1] + after)
                self.cursor_y += len(self.clipboard) - 1
                self.cursor_x = len(self.clipboard[-1])
        
        self.modified = True
        self.message = f"Pasted {len(self.clipboard)} line(s)"
        self.message_color = curses.COLOR_GREEN
    
    def delete_all(self):
        """Delete all text"""
        self.lines = ['']
        self.cursor_x = 0
        self.cursor_y = 0
        self.modified = True
        self.message = "Deleted all text"
        self.message_color = curses.COLOR_YELLOW
    
    def handle_key(self, key):
        """Handle keyboard input"""
        # Clear message on most keys
        if key not in [curses.KEY_UP, curses.KEY_DOWN, curses.KEY_LEFT, curses.KEY_RIGHT]:
            self.message = ""
        
        # Navigation
        if key == curses.KEY_UP:
            self.move_cursor(0, -1)
        elif key == curses.KEY_DOWN:
            self.move_cursor(0, 1)
        elif key == curses.KEY_LEFT:
            if self.cursor_x > 0:
                self.move_cursor(-1, 0)
            elif self.cursor_y > 0:
                self.cursor_y -= 1
                self.cursor_x = len(self.lines[self.cursor_y])
        elif key == curses.KEY_RIGHT:
            if self.cursor_x < len(self.lines[self.cursor_y]):
                self.move_cursor(1, 0)
            elif self.cursor_y < len(self.lines) - 1:
                self.cursor_y += 1
                self.cursor_x = 0
        elif key == curses.KEY_HOME:
            self.cursor_x = 0
        elif key == curses.KEY_END:
            self.cursor_x = len(self.lines[self.cursor_y])
        elif key == curses.KEY_PPAGE:  # Page Up
            self.page_up()
        elif key == curses.KEY_NPAGE:  # Page Down
            self.page_down()
        
        # Editing
        elif key in [ord('\n'), ord('\r'), curses.KEY_ENTER, 10, 13]:
            self.insert_newline()
        elif key in [curses.KEY_BACKSPACE, 127, 8, ord('\b')]:
            self.delete_char()
        elif key == curses.KEY_DC:  # Delete key
            self.delete_char_forward()
        elif key == ord('\t'):  # Tab
            for _ in range(self.tab_size):
                self.insert_char(' ')
        
        # Control commands
        elif key == 19:  # Ctrl+S
            self.save_file()
        elif key == 17:  # Ctrl+Q
            if self.modified:
                self.message = "File modified! Use Ctrl+S to save, Ctrl+X to quit without saving"
                self.message_color = curses.COLOR_YELLOW
            else:
                self.running = False
        elif key == 24:  # Ctrl+X
            self.running = False
        elif key == 1:  # Ctrl+A
            self.select_all()
        elif key == 3:  # Ctrl+C
            self.copy_line()
        elif key == 22:  # Ctrl+V
            self.paste()
        elif key == 4:  # Ctrl+D
            self.delete_all()
        
        # Regular characters
        elif 32 <= key <= 126:
            self.insert_char(chr(key))
    
    def run(self):
        """Main editor loop"""
        curses.curs_set(1)
        
        while self.running:
            self.draw()
            key = self.stdscr.getch()
            self.handle_key(key)
        
        curses.curs_set(0)


def main(stdscr):
    """Entry point for curses"""
    fm = FileManager(stdscr)
    fm.run()


if __name__ == '__main__':
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    
    print("\nüëã Goodbye!\n")
